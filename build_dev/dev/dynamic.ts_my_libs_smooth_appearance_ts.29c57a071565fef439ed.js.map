{"version":3,"file":"dynamic.ts_my_libs_smooth_appearance_ts.29c57a071565fef439ed.js","mappings":";;;;;;;;;;;;;AAWA,IAAMA,gBAAgB,GAAG;EACrBC,IAAI,EAAE,IADe;EAErBC,SAAS,EAAE;AAFU,CAAzB;AAKA,IAAIC,QAAQ,GAAgC,IAAIC,oBAAJ,CAAyBC,qBAAzB,EAAgDL,gBAAhD,CAA5C;AACA,IAAIM,aAAa,GAAG,CAApB;;AAGA,SAASC,IAAT,CAAcC,gBAAd,EAAgD;EAC5C,IAAI,CAACL,QAAL,EAAe;;EAEf,KAAyB,iDAAzB,EAAyBM,8BAAzB,EAAyBA,IAAzB,EAA2C;IAAtC,IAAIC,YAAY,yBAAhB;IACD,IAAMC,YAAY,GAAGC,QAAQ,CAACC,gBAAT,CAA0BH,YAAY,CAACI,QAAvC,CAArB;;IAEA,KAAK,IAAIC,WAAT,IAAwBJ,YAAxB,EAAsC;MAClC,IAAI,CAACA,YAAY,CAACK,cAAb,CAA4BD,WAA5B,CAAL,EAA+C;MAE/C,IAAME,kBAAkB,GAAGN,YAAY,CAACI,WAAD,CAAvC;MAEAE,kBAAkB,CAACC,YAAnB,CAAgC,mBAAhC,EAAqD,UAAGR,YAAY,CAACS,OAAhB,CAArD;MACAF,kBAAkB,CAACG,SAAnB,CAA6BC,GAA7B,CAAiC,UAAGX,YAAY,CAACS,OAAhB,EAAuB,OAAvB,CAAjC;MACAF,kBAAkB,CAACG,SAAnB,CAA6BC,GAA7B,CAAiC,UAAGX,YAAY,CAACS,OAAhB,EAAuB,MAAvB,CAAjC;MACAhB,QAAQ,CAACmB,OAAT,CAAiBL,kBAAjB;MACAX,aAAa;IAChB;EACJ;AACJ;;AAGD,SAASD,qBAAT,CAA+BM,YAA/B,EAAwE;EACpE,KAAwB,yCAAxB,EAAwBF,0BAAxB,EAAwBA,IAAxB,EAAsC;IAAjC,IAAIM,WAAW,qBAAf;IACD,IAAI,CAACA,WAAW,CAACQ,cAAjB,EAAiC;IAEjC,IAAMC,YAAY,GAAGT,WAAW,CAACU,MAAZ,CAAmBC,YAAnB,CAAgC,mBAAhC,CAArB;IAEA,IAAI,CAACF,YAAL,EAAmB;IAEnBT,WAAW,CAACU,MAAZ,CAAmBL,SAAnB,CAA6BO,MAA7B,CAAoC,UAAGH,YAAH,EAAe,MAAf,CAApC;IACAI,UAAU,CAACC,yBAAyB,CAACC,IAA1B,CAA+B,IAA/B,EAAqCf,WAAW,CAACU,MAAjD,CAAD,EAA2D,IAA3D,CAAV;EACH;AACJ;;AAGD,SAASI,yBAAT,CAAmCE,OAAnC,EAAmD;EAC/C,IAAI,CAAC5B,QAAL,EAAe;EAEf,IAAMqB,YAAY,GAAGO,OAAO,CAACL,YAAR,CAAqB,mBAArB,CAArB;EACAK,OAAO,CAACX,SAAR,CAAkBO,MAAlB,CAAyB,UAAGH,YAAH,EAAe,OAAf,CAAzB;EACAO,OAAO,CAACC,eAAR,CAAwB,mBAAxB;EACA7B,QAAQ,CAAC8B,SAAT,CAAmBF,OAAnB;EACAzB,aAAa;;EAIb,IAAIA,aAAa,IAAI,CAArB,EAAwB;IACpBH,QAAQ,CAAC+B,UAAT;IACA/B,QAAQ,GAAG,IAAX;EAEH;AACJ","sources":["webpack:///./ts/my_libs/smooth_appearance.ts"],"sourcesContent":["// элементы появляются с анимацией по мере листания страницы, для этого используем IntersectionObserver\n//  - для того чтобы добавить нужному DOM элементу такое поведение нужно внести обьект с его с електором в\n//    animate_elements, своиство animate применяет класс с анимацией по этому имяни к DOM елементу.\n//    в дальнейшем к этому имяни будут добавлены суффиксы _main _out, примеры анимаций в anims.less\n//  - _main добавляет своиство transition к DOM елементу что в дальнейшем позволит плавно проявить элемент\n//  - _out скрывает элемент, в момент intersection класс \"animate_name\"_out удаляется и обьект плавно появляется.\n//  - спустя секунду проявленный элемент отписываетя от IntersectionObserver, также в нем удаляеются все системные классы и атрибуты этого скрипта.\n\ntype TAnimateElement = { selector: string; animate: string };\ntype TAnimateElements = TAnimateElement[];\n\nconst observer_options = {\n    root: null,\n    threshold: 0.4,\n};\n\nlet observer: IntersectionObserver | null = new IntersectionObserver(intersection_callback, observer_options);\nlet observe_count = 0;\n\n// ищем DOM элементы по селекторам, подписываем их на observer, добавляем классы и атрибуты\nfunction main(animate_elements: TAnimateElements) {\n    if (!observer) return;\n\n    for (let data_element of animate_elements) {\n        const DOM_elements = document.querySelectorAll(data_element.selector); // ищем все элементы по селектору\n\n        for (let DOM_element in DOM_elements) {\n            if (!DOM_elements.hasOwnProperty(DOM_element)) continue; // in проходит и по своиствам прототипа, нам это не нужно\n\n            const target_DOM_element = DOM_elements[DOM_element];\n\n            target_DOM_element.setAttribute(\"data-animate_name\", `${data_element.animate}`);\n            target_DOM_element.classList.add(`${data_element.animate}_main`);\n            target_DOM_element.classList.add(`${data_element.animate}_out`);\n            observer.observe(target_DOM_element);\n            observe_count++;\n        }\n    }\n}\n\n// вызывается в момент пересечения элемента\nfunction intersection_callback(DOM_elements: IntersectionObserverEntry[]) {\n    for (let DOM_element of DOM_elements) {\n        if (!DOM_element.isIntersecting) continue;\n\n        const animate_name = DOM_element.target.getAttribute(\"data-animate_name\");\n\n        if (!animate_name) continue;\n\n        DOM_element.target.classList.remove(`${animate_name}_out`);\n        setTimeout(intersection_out_callback.bind(null, DOM_element.target), 1000);\n    }\n}\n\n// вызывается спустя ~1 sec после intersection_callback, отписываем элемент от observer, удаляем все что мы в него добавляли (классы, атрибуты)\nfunction intersection_out_callback(element: Element) {\n    if (!observer) return;\n\n    const animate_name = element.getAttribute(\"data-animate_name\")!;\n    element.classList.remove(`${animate_name}_main`);\n    element.removeAttribute(\"data-animate_name\");\n    observer.unobserve(element);\n    observe_count--;\n\n    // console.log(observe_count);\n\n    if (observe_count == 0) {\n        observer.disconnect();\n        observer = null;\n        // console.log(\"observer - bye\");\n    }\n}\n\nexport { main };\nexport type { TAnimateElement, TAnimateElements };\n"],"names":["observer_options","root","threshold","observer","IntersectionObserver","intersection_callback","observe_count","main","animate_elements","_i","data_element","DOM_elements","document","querySelectorAll","selector","DOM_element","hasOwnProperty","target_DOM_element","setAttribute","animate","classList","add","observe","isIntersecting","animate_name","target","getAttribute","remove","setTimeout","intersection_out_callback","bind","element","removeAttribute","unobserve","disconnect"],"sourceRoot":""}